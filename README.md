# BlockSolver
A Rubik's Cube block solver

# CubieCube #
A struct defining 4 arrays for cp, co, ep and eo

# BlockCube #
The block representation of a CubieCube

cl: bit array of where the corners are
cp: array of the corner permutation
co: array of the corner orientations
el: bit array of where the edges are
ep: array of the edge permutation
eo: array of the edge orientations

Example for a 1-corner and 3-edge block:
cl: [0, 0, 0, 1, 0, 0, 0, 0]
cp: [0]
co: [1]
el: [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]
ep: [0, 2, 1]
eo: [1, 1, 0]

Each of these states can be translated to a single integer called a coordinate.
Each coordinate ranges from 0 to the number of possible states and can be used as an index in a lookup table

# CoordinateBlockCube #
The coordinate representation of a subgroup of the cube pieces
(for example the three edges and one corner of a 2x2x2 block)
There are six coordinates that represent the state of the cubies:

ccl: the positions of the corners regardless of their order
ccp: the permutation of the corners
cco: the orientation of the corners
cel: the positions of the edges regardless of their order
cep: the permutation of the edges
ceo: the orientation of the edges


# Move Tables #

TODO

# Search Algorithms #

TODO

# Pruning Tables #

Pruning tables are used to accelerate the search for solutions. Basically the table stores the results of a function h (called a heuristic) such that for any CoordinateBlockCube cbc, h(cbc) is a lower-bound estimate of the optimal solution length for state cbc. This estimate can be used to prune the search tree as it is not necessary to search in a sub-tree that would be generated by a node with a high estimate. 

More concretely if you are looking for solutions under a given depth threshold max_depth, and if after m moves your run into a state with estimate h, and m + h > max_depth, then you know you can avoid generating the children of that state because they will not lead you to a solution that satisfies the criterion max_depth. The closer the estimate is to the optimal solution length for the state, the more nodes the search algorithm will be able to prune.

Usually the better pruning values require a lot of memory because they take into account the multiple caracteristics of each state (layout, permutation and orientation). As there are many possible combinations of those caracteristics, the number of entries in the table is higher. On the other hand a more 'lazy' heuristic table (that only takes into account the layout of the pieces for instance) will have a lower memory footprint but will store values that are further away from the optimal solution length on average. The best pruning table is mainly a tradeoff between memory footprint and mean value.

TODO: Description of the algorithms for pruning table generation

### Exact Pruning Value ###

This is the optimal pruning value. It is exactly equal to the optimal solution length and allows the search algorithm to prune every sub-optimal path, leaving only those which are optimal. This makes the search optimally fast, as it allows to only generate the path to the shortest solutions. (Now that I write about this and use the word 'optimal' 5 times in 3 sentences, I think I should rename this the Optimal Pruning Value). 

Unfortunaltely it starts becoming unusable for high number of pieces in the block. For instance with 2 corners and 2 edges, the table has size 100 B, but for 5 corners and 5 edges you would need about 30 GB of RAM which I don't have (lol). So building a 2x2x2 or even a 2x2x3 block using an optimal pruning value would be feasible, but not the first two blocks of the Roux method at once.

### Permutation Pruning Value ###

This corresponds to the optimal number of moves needed to restore the block pieces to their home locations, without consideration for their respective orientations. This reduces the table size significantly, making it usable for about 10-11 pieces in the block.

TODO: Average value study for this pruning value

### Orientation Pruning Value ###

Orientation Pruning value corresponds to the number of moves needed to restore the pieces to the block home location in the solved orientation, without consideration for their permutation among the block's cubie locations. The table size for this pruning value is smaller than the permutation pruning value on higher number of pieces (12+ pieces). However I expect this OPV to be not as efficient as PPV.

TODO: Average value study for this pruning value

### Layout Pruning Value ###

LPV corresponds to the minimal number of moves needed to restore the block pieces to the block location, regardless of their orientations and permutation. The table size for this is very very low, but I expect it ot be very inefficient

TODO: Average value study for this pruning value
