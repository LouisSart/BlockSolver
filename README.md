# BlockSolver
This program can solve any of 4 different blocks (1x2x3, 2x2x2, 2x2x3 or F2L-1) on the input scramble.
It will find all optimal solutions over all possible symmetries of the cube.

It can also solve the F2L-1 suboptimally in three steps : 2x2x2, 2x2x3 and F2L-1 by switching before each step.

### Configuration ###

```console
cmake -B build
```

### Compilation ###

```console
cmake --build build
```

### Run script ###
Run using :

```console
./build/src/block_solver <step> <scramble>
```
where ```step``` can be any of ```123```, ```222```, ```223```, ```F2L-1```, ```multistep```, ```two_gen_finish```, ```two_gen_reduction```, ```two_gen```

 - ```123```, ```222```, ```223```, ```F2L-1```: Solve the given block optimally
 - ```multistep``` : Solve the best F2L-1 in 3 steps: 2x2x2 -> 2x2x3 -> F2L-1. The multistep solver is allowed to NISS before each step
 - ```two_gen_finish``` : Solve a two gen position optimally, e.g. a position of the cube that belongs to the subgroup generated by R and U moves. The solver will find optimal solutions using only moves from {U, U2, U', R, R2, R'}
 - ```two_gen_reduction``` : Reduce the given scramble to two gen from any orientation
 - ```two_gen``` : Find every two gen reduction and solve them optimally using the two gen finish solver

### Options ###

 - `-M`: maximum solution length. If optimal is shorter than `M` moves, then only optimals will be computed. Default `-M 15`
 - `-b`: maximum number of solutions kept at each step (only for multistep solver). Use this parameter to reduce search time and memory usage or increase search breadth. Default `-b 5000`
 - `-s`: slackness of the optimal solver. When this parameter is set, the solver is allowed to use `s` more moves than optimal to produce solutions. Default `-s 0` (optimal only)
 - `-L`: linear parameter. If set, the solver will also solve the inverse of the given position.

Examples :

```console
epicier@w-Optiplex:~/BlockSolver$ ./build/src/block_solver 222 -M 6 "R L U D F B"
B' U' D' L' (4)
B' U' D' R' (4)
F' B' D' L' (4)
F' B' D' R' (4)
F' B' U' L' (4)
F' B' U' R' (4)
F' U' D' L' (4)
F' U' D' R' (4)
```

```console
epicier@w-Optiplex:~/BlockSolver$ ./build/src/block_solver F2L-1 -L "R' U' F L D F2 R2 D L2 U' L2 F2 U' F L2 D' F2 R' D' B2 U2 L' F2 R' U' F"
D2 B' U2 R2 B2 L F' L' F U (10)
(R2 U' R2 L2 U' B' L U D F' U2) (11)
(U' B D R' F2 B' L D2 B' L2 D2) (11)
(U' F' B2 R' B' D R' B2 D2 B2 U) (11)
(U' D' F B' L' B2 U2 L2 F2 B R2) (11)
```

```console
epicier@w-Optiplex:~/BlockSolver$ ./build/src/block_solver multistep -M 13 -b 1000 "R' U' F  D' B' U' D2 L' U2 L B2 R2 B2 U2 F' L B2 R' U' F"
----------------
D' L' B2 U2 L2 // 2x2x2 (5/5)
(F2 R2 F U F2) // 2x2x3 (5/10)
(U2 R2 U') // F2L-1 (3/13)
----------------
D' L' B2 U2 L2 // 2x2x2 (5/5)
(F2 R2 F U F2) // 2x2x3 (5/10)
B U' B' // F2L-1 (3/13)
```

```console
epicier@w-Optiplex:~/BlockSolver$ ./build/src/block_solver two_gen -M 15 -s 1 "R U R U R U' R' U2 R' U2 R U2 R' U' R2 U R2"
U R U' R2 U' R2 U R' U R2 U' R2 U' R (14)
R2 U' R2 U R2 U' R' U2 R' U2 R U R' U' R' (15)
R2 U' R2 U R2 U R' U' R U R2 U' R2 U' R (15)
R2 U2 R U R' U' R U' R U2 R U2 R' U R2 (15)
```

```console
epicier@w-Optiplex:~/BlockSolver$ ./build/src/block_solver two_gen -M 25 -L "R' U' F L D2 R2 U' B2 F2 R2 U' R2 U2 L' F' D2 B' L D' L' U2 R' B2 R' U' F"
------------
(U' L2 F' U F' B' D' B' R' L') // Reduction (10/10)
(D2 B2 D B2 D B2 D2 B2 D B2 D2 B2 D B' D2) // Finish (15/25)
```

# Goal #

The purpose of this tool is to find human findable block skeletons. Optimal solutions to a 1x2x3, 2x2x2, 2x2x3 or F2L-1 can be found, as well as multi-step F2L-1 solutions using NISS before each step. Leave-3C-skeletons would be the natural next step.

### NISS ###

The multistep solver looks for linear solutions for each step on both inverse and normal.  
It is currently possible to input a scramble between brackets, but not a skeleton with subparts being on inverse.  
I don't plan on implementing a two sided search algorithm because it prevents the use of pruning tables, which slows down the algorithm by a lot.

### EO and DR ###

EO is implemented but is not yet usable. I don't think it is very interesting to have another EO>DR solver since there are already very good ones. See [nissy](https://nissy.tronto.net/), [cubelib](https://github.com/Jobarion/cubelib) and [Mallard](https://joba.me/mallard/) for human Thistlewaite solutions.
One application that I can see for those steps is blockino solving, but this is not the priority implementation.

# Some documentation #

### CoordinateBlockCube ###

I use six coordinates to represent the state of a block which are stored in the CoordinateBlockCube structure

 + ccl: the positions of the corners regardless of their order
 + ccp: the permutation of the corners
 + cco: the orientation of the corners
 + cel: the positions of the edges regardless of their order
 + cep: the permutation of the edges
 + ceo: the orientation of the edges

### Two gen coordinate ###

Numbering the two gen corner permutations was not obvious to me at all at first. I used ideas from [Jaap Sherphuis](https://www.jaapsch.net/puzzles/pgl25.htm) to represent the current corner state as a "pairing pattern permutation". This permutation is then transformed into a coordinate ranging from 0 to 5! - 1 = 119.

To perform the two gen reduction I use a mapping of every corner permutation to its "two-gen-wise representant". Every two gen permutation is associated with representant 0, every permutation that is F away from two gen is numbered 1 etc... The association table is filled using a BFS algorithm. There are 336 = 8! / 5! equivalence classes, giving a coordinate that ranges from 0 to 335.

### Move Tables ###

Move tables are transition tables that store the result of applying each possible move to a given coordinate. This allows to perform moves faster that permuting digits in an array on the CubieCube level (the only cost is the lookup in the table). The move tables are precomputed at runtime and then written on the disk for later use.

### Pruning ###

For small blocks (1x2x3 and 2x2x2) the pruning value is optimal. The block coordinates described earlier are combined together to give a single coordinate that ranges form 0 to the number of possible states this block can be in. The pruning table is then filled with the optimal distance to solved for each of these states using a BFS generator.

For bigger blocks (2x2x3, F2L-1) this strategy is too computationally expensive so I split the block in several smaller subblocks. The pruning value for the whole block is computed as the maximum heuristic value over all subblocks. The 2x2x3 block is splitted into two 1x2x3 blocks which share two corners and one edge. This is memory efficient because I can use the same table to compute the value for each subblock.

The program is still pretty slow at table generation when the tables are more than ~100 Mo. I don't intend to build a very optimized code with huge tables, but I'd still appreciate reaching 1 Go tables in a reasonable amount of time. If you have any idea on how to optimize it, let me know.

# Search #

The searches are performed using an IDA* algorithm with a slackness parameter. Setting this parameter will allow the solver to use  extra moves to find solutions.